作为拥有 20 年量化经验的工程师，我会从**存储成本**、**计算性能**、**数值精度**和**业务易用性**四个维度来评估三种方案：`float32`、`Decimal` 和 “*1000 用 `int`” 存储。下面分别给出优缺点，并按四个维度打分（1–10 分，分数越高越优）。

------

## 1. `float32`

> **存储**：4 bytes/值
>  **精度**：约 7 位十进制有效数字
>  **运算**：硬件原生支持，速度快

| 维度         | 说明                                                         | 评分    |
| ------------ | ------------------------------------------------------------ | ------- |
| 存储成本     | 占用仅为 `float64` 的一半，在海量分钟/秒级数据下能显著节省内存和磁盘； | 9       |
| 计算性能     | CPU、GPU 都对单精度有极高优化，向量化、并行运算速度快，I/O 也更少； | 9       |
| 数值精度     | 7 位有效数字足够表示如 `12345.678`；但若累计误差或极小价差（0.0001）较敏感，可能出现微量舍入； | 6       |
| 业务易用性   | Pandas/NumPy 原生支持，直接 `astype('float32')`；但在绝对精度要求高的场景需要额外校验； | 8       |
| **综合得分** |                                                              | **8.0** |

**适用场景**：大多数量化回测、因子计算、机器学习特征工程，且对 0.0001 价差精度容忍度较高。

------

## 2. `Decimal` （Python `decimal.Decimal`）

> **存储**：对象化，内存开销大（数十到上百字节/值）
>  **精度**：可任意设定，十进制精确，无二进制舍入误差
>  **运算**：软件模拟，速度慢

| 维度         | 说明                                                         | 评分    |
| ------------ | ------------------------------------------------------------ | ------- |
| 存储成本     | 每个 `Decimal` 是 PyObject，含指针、元数据和数值本身，超出数百倍于原生类型； | 2       |
| 计算性能     | 任意精度代价高，尤其在大表或循环中会成为瓶颈；               | 3       |
| 数值精度     | 十分*精确*，适合对每笔交易价差、累计盈亏的绝对精度有严格要求的场景； | 10      |
| 业务易用性   | API 与 Python 语义一致，操作直观，但要小心上下文设置（四舍五入规则、精度上下文）；与 Pandas/NumPy 集成不够平滑。 | 5       |
| **综合得分** |                                                              | **5.0** |

**适用场景**：对每笔交易的极致精度要求（如衍生品结算、清算系统），但不适合海量分钟/秒级数据分析。

------

## 3. `int` * 1000 （整数存储：`price * 1000`）

> **存储**：4 bytes（`int32`）或 8 bytes（`int64`）
>  **精度**：精确到千分位（0.001）；无浮点误差
>  **运算**：整数运算速度快，向量化友好

| 维度         | 说明                                                         | 评分    |
| ------------ | ------------------------------------------------------------ | ------- |
| 存储成本     | 与 `float32` 类似（`int32`），或双倍（`int64`）；            | 8       |
| 计算性能     | 整数运算更快且无舍入，向量化效果好；                         | 9       |
| 数值精度     | 精确到 0.001 元，满足大多数行情精度；若需要 0.0001，需 *10000； | 9       |
| 业务易用性   | 代码里要记得“除以 1000”才能还原，略增加认知成本；需要统一文档／接口约定，否则易混淆；与数据库的 `INTEGER`、`BIGINT` 类型天然契合。 | 7       |
| **综合得分** |                                                              | **8.3** |

**适用场景**：对“固定小数位”精确存储且海量数据场景（分钟/秒级行情、中频因子），同时希望全行无浮点误差。

------

## 综合推荐

| 方案         | 综合得分 | 适用建议                                                     |
| ------------ | -------- | ------------------------------------------------------------ |
| `int * 1000` | 8.3      | **首选**：若行情精度固定两～三位小数，且追求无浮点误差、与数据库字段对齐； |
| `float32`    | 8.0      | **次选**：快速原型、机器学习特征、回测和策略开发，能接受微量舍入误差； |
| `Decimal`    | 5.0      | 极端精度场景（清算系统、合规报表）再用，日常分析/回测不推荐； |

**最终推荐**：

* **主要方案**：用 `int` 存 `price * 1000`（或按业务需 *10000），在读取时除回原价。确保全链路（ETL、数据库、分析脚本）都遵守相同约定，既节省存储，又保证绝对精度；
* **辅助方案**：策略开发／快速探索阶段可临时用 `float32`，跑完后再转换为整数存储。



作为拥有20年经验的量化工程师，我处理过PB级的金融数据存储问题。针对OHLC数据的存储方案选择，需要平衡精度、性能、存储效率和开发成本。以下是深度分析：

### 方案对比分析

#### 1. **float32 (单精度浮点数)**
```python
# 存储示例
df['open'] = df['open'].astype('float32')
```
**优点**：
- **存储效率**：4字节/值，比float64节省50%空间
- **计算性能**：现代CPU/GPU对float32有硬件加速
- **向量化支持**：完美兼容numpy/pandas计算生态
- **开发便捷**：无需转换，直接计算

**缺点**：
- 精度范围：±10^38 (足够覆盖所有金融产品)
- 精度损失：有效数字6-7位（价格变动0.0001时可能有舍入误差）
- 累计误差：长期计算可能产生微小偏差

#### 2. **Decimal (高精度定点数)**
```python
from decimal import Decimal
df['open'] = df['open'].apply(Decimal)
```
**优点**：
- **完美精度**：完全避免浮点误差，适合财务计算
- **精确控制**：可设置精确小数位数
- **无舍入问题**：特别适合利息计算等场景

**缺点**：
- **存储膨胀**：Python Decimal对象约28字节/值，是float32的7倍
- **计算极慢**：比float32慢100倍以上
- **兼容性差**：不兼容numpy/pandas向量化操作
- **内存消耗**：大数据集易导致OOM

#### 3. **int缩放存储 (原始值×缩放因子)**
```python
SCALE = 1000  # 保留3位小数
df['open_int'] = (df['open'] * SCALE).astype('int32')
```
**优点**：
- **无损存储**：可精确还原原始值
- **存储效率**：4字节/值(int32)，与float32相当
- **无精度问题**：整数运算无舍入误差
- **哈希优化**：适合作为字典键

**缺点**：
- **开发成本**：所有计算需考虑缩放因子
- **范围限制**：int32最大±2.1e9 (对应价格±2.1百万)
- **类型转换**：输出需额外转换
- **易出错**：忘记缩放会导致严重错误

### 量化场景关键考量

1. **精度需求**：
   - 股票/期货：float32足够（最小变动单位0.01）
   - 加密货币：可能需要更高精度（如0.000001）
   - 衍生品定价：Decimal更安全

2. **数据规模**：
   ```python
   # 1亿条OHLC记录的空间对比
   float32: 4值×4字节×100M = 1.6GB
   int缩放: 4值×4字节×100M = 1.6GB 
   Decimal: 4值×28字节×100M = 11.2GB
   ```

3. **计算类型**：
   - 简单指标（MA/波动率）：float32足够
   - 复杂衍生品定价：Decimal更安全
   - 高频tick数据：int缩放性能最佳

### 推荐方案：分层的混合策略

#### 热数据存储 (在线计算)
```python
# 使用float32 + 单位转换
def optimize_ohlc(df):
    return df.astype({
        'open': 'float32',
        'high': 'float32',
        'low': 'float32',
        'close': 'float32',
        'volume': 'float32'  # 单位转换为"千股"
    })
```
**理由**：平衡性能和精度，适合99%的量化场景

#### 冷数据存储 (长期归档)
```python
# 使用缩放整数 + Parquet压缩
SCALE = 10000  # 保留4位小数

def archive_ohlc(df):
    return df.assign(
        open = (df['open'] * SCALE).astype('int32'),
        high = (df['high'] * SCALE).astype('int32'),
        low = (df['low'] * SCALE).astype('int32'),
        close = (df['close'] * SCALE).astype('int32')
    ).to_parquet(compression='ZSTD')
```
**理由**：保证无损压缩，节省60%存储空间

#### 特殊场景
```python
# 使用Decimal的特定列
from decimal import Decimal

class PreciseCalculator:
    def __init__(self):
        self.precision = Decimal('0.00001')
    
    def calculate_interest(self, principal, rate):
        return Decimal(principal) * Decimal(rate).quantize(self.precision)
```
**理由**：仅用于需要绝对精度的财务计算

### 综合评分 (满分10分)

| 维度         | float32 | Decimal | int缩放 |
| ------------ | ------- | ------- | ------- |
| 存储效率     | 9       | 3       | 9       |
| 计算性能     | 10      | 2       | 8       |
| 开发便利性   | 10      | 5       | 6       |
| 精度保证     | 7       | 10      | 10      |
| 系统兼容性   | 10      | 6       | 8       |
| **综合得分** | **9.2** | **5.2** | **8.2** |

### 最终建议

1. **主力方案**：float32 (得分9.2)
   - 适用于95%的量化场景
   - 配合适当的数据预处理：
     ```python
     # 价格单位转换为"元"，避免极小值
     df['open'] = df['open'] / 100.0  # 如原始数据为"分"
     ```

2. **备选方案**：int缩放 (得分8.2)
   - 特定场景使用：
     - 加密货币微小价格变动
     - 需要精确哈希的场景
     - 长期数据归档
   - 实现模板：
     ```python
     class ScaledStorage:
         SCALE = 1000  # 3位小数
         
         def store(self, price: float) -> int:
             return int(price * self.SCALE)
             
         def retrieve(self, value: int) -> float:
             return value / self.SCALE
     ```

3. **避免使用**：Decimal (得分5.2)
   - 仅在以下情况考虑：
     - 财务结算系统
     - 监管合规要求
     - 利息计算等绝对精度场景

> **行业实践**：顶级量化基金如Renaissance Technologies和Two Sigma主要采用float32方案，配合内存计算和GPU加速。高盛等投行在结算系统中使用Decimal，但交易系统仍用float32。

最终选择应基于：
1. 数据规模（>1TB倾向float32）
2. 精度要求（衍生品定价需更严格）
3. 硬件资源（内存有限时避免Decimal）
4. 团队技能（int缩放需严格代码规范）