并不是“完全没考虑”个股波动风险——Markowitz 均值–方差正是把风险量化成**协方差矩阵**里的对角线元素（方差）和非对角元素（协方差）。不过在你那个多期代码里有两个“隐含”小细节，可能让你觉得它忽略了波动性：

1. **每期用的是「分位价」样本协方差**
    你在第 2 步里用

   ```python
   L = np.log(prices / P0[:,None])     # N×Q 的 log-return 样本
   Sigma_t = (L_centered @ L_centered.T)/(Q-1)
   ```

   这只反映了「分位预测」之间的横截面差异，也就是**分位不确定性**，并不是基于历史「时间序列」的波动率。如果你想捕捉每只股票 **真实的** 日内或历史波动，就需要把基于过去真实收益的样本协方差（或 EWMA、GARCH 等）也加进来。

2. **各期之间不建交叉协方差**
    你把每期 $\Sigma_t$ 堆成了一个大块对角矩阵

   ```python
   Sigma_big = block_diag(Σ₁, Σ₂, …, Σ_T)
   ```

   这意味着“第 1 天和第 2 天的收益被当成完全不相关”——同一只股票跨期的波动和自相关就没体现。

------

### 如何把「真实波动率」加进来？

* **历史协方差**：用过去 $K$ 天的 **对数收益序列** 来估计 $\Sigma$，而不是用分位预测的 $Q$ 样本。

  ```python
  # 举例：对 stock_i 用过去 60 天的 log-return 序列算方差
  logrets = np.log(price_history / price_history.shift(1)).dropna()
  Sigma_hist = logrets.cov().values  # (N×N) 的历史协方差
  ```

* **混合协方差**：把「分位不确定性协方差」和「历史波动协方差」按权重合并：

  Σmix=α Σquantile+(1−α) Σhist.  \Sigma_{\rm mix}    = \alpha\,\Sigma_{\rm quantile}    + (1-\alpha)\,\Sigma_{\rm hist}.

* **EWMA / GARCH**：用加权或模型动态预测波动，再填入对角或整个矩阵。

------

### 结论

* **Markowitz MV** 本身是“二阶矩”（均值、方差/协方差）模型，**确实考虑了个股的波动风险**（on-diagonal 的方差项），也考虑了资产间的协动性。
* 只是你示例里用的 $\Sigma_t$ 是基于「分位预测」的样本方差，而不是资产历史或实时的**真实波动率**。如果你想让组合优化更贴近实盘风险，要把**历史或模型预测的波动协方差**也加进 $\Sigma$ 里。